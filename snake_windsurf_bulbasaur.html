<!--
  Snake Game - Windsurf Bulbasaur Enhancement
  
  Model: Windsurf Bulbasaur (test model)
  Base: GPT-OSS snake_gptoss.html
  Generation: Single-shot enhancement
  Prompt: "This is a simple Snake Game in HTML/CSS/JS, can you spice this up 
          significantly so it feels like a much prettier and more polished game."
  
  Result: Enhanced with sophisticated glassmorphism effects, vignette overlays,
  HUD with badges, and refined visual polish. Demonstrates strong enhancement
  capabilities with unique aesthetic choices.
-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Neon Snake</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
      rel="stylesheet">
<style>
  :root {
    --bg-dark: #07080b;
    --bg-grad-a: #0b1220;
    --bg-grad-b: #091a14;
    --grid: #121219;
    --hud: rgba(0,0,0,0.45);
    --snake-head: #00ffcc;
    --snake-body: #15d1a3;
    --snake-glow: #00ffc8;
    --food: #ff4d6d;
    --overlay-bg: rgba(5,6,8,0.85);
    --text: #e8f6f2;
    --accent: #7bffb2;
    --warn: #ffb703;
  }

  * { box-sizing: border-box; }

  body {
    margin: 0;
    height: 100vh;
    font-family: "Press Start 2P", cursive;
    color: var(--text);
    overflow: hidden;
    display: grid;
    grid-template-rows: auto 1fr auto;
    align-items: center;
    justify-items: center;
    background: radial-gradient(1200px 800px at 20% 10%, rgba(0,255,204,0.08), transparent 60%),
                radial-gradient(1000px 700px at 80% 90%, rgba(255,64,129,0.06), transparent 60%),
                linear-gradient(135deg, var(--bg-grad-a), var(--bg-grad-b));
  }

  .game-wrap {
    position: relative;
    width: min(92vmin, 640px);
    aspect-ratio: 1 / 1;
    display: grid;
    place-items: center;
    filter: drop-shadow(0 0 30px rgba(0,255,204,0.15));
  }

  canvas {
    width: 100%;
    height: 100%;
    background: linear-gradient(180deg, #0a0f14 0%, #0c1016 100%);
    border: 3px solid #10151b;
    border-radius: 16px;
    image-rendering: pixelated;
    box-shadow: 0 0 0 2px rgba(123,255,178,0.15) inset,
                0 0 40px rgba(0,255,200,0.12);
  }

  .vignette {
    position: absolute;
    inset: 0;
    border-radius: 16px;
    pointer-events: none;
    background: radial-gradient(120% 120% at 50% 50%, transparent 55%, rgba(0,0,0,0.45) 100%);
  }

  .hud {
    position: absolute;
    top: 10px;
    left: 10px;
    right: 10px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
    z-index: 2;
  }
  .badge {
    background: var(--hud);
    padding: 8px 10px;
    border-radius: 10px;
    border: 1px solid rgba(123,255,178,0.2);
    text-shadow: 0 0 6px rgba(0,255,200,0.35);
    box-shadow: 0 0 0 2px rgba(0,0,0,0.25) inset;
    font-size: 12px;
  }
  .badge strong { color: var(--accent); }
  .controls {
    display: flex;
    gap: 8px;
  }
  .btn {
    background: var(--hud);
    border: 1px solid rgba(255,255,255,0.15);
    color: var(--text);
    padding: 8px 10px;
    border-radius: 10px;
    font-size: 12px;
    cursor: pointer;
  }
  .btn:hover { filter: brightness(1.15); }

  .overlay {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    font-size: 1rem;
    background: var(--overlay-bg);
    border-radius: 16px;
    pointer-events: none;
    opacity: 0;
    transition: opacity .2s ease;
  }
  .overlay .panel {
    background: rgba(0,0,0,0.35);
    border: 1px solid rgba(255,255,255,0.15);
    padding: 18px;
    border-radius: 12px;
    box-shadow: 0 0 30px rgba(0,255,200,0.15);
  }
  .visible { opacity: 1; }

  /* Mobile controls */
  .mobile-controls {
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    display: grid;
    grid-template-columns: 60px 60px 60px;
    grid-template-rows: 60px 60px 60px;
    gap: 6px;
    opacity: .9;
    touch-action: manipulation;
    user-select: none;
  }
  .ctl {
    background: rgba(0,0,0,0.35);
    border: 1px solid rgba(255,255,255,0.12);
    border-radius: 12px;
    display: grid;
    place-items: center;
    color: var(--accent);
    box-shadow: 0 0 12px rgba(0,255,200,0.15);
  }
  .ctl span { pointer-events: none; }
  .ctl:active { filter: brightness(1.25); }

  @media (hover: none) and (pointer: coarse) {
    .mobile-controls { display: grid; }
  }
  @media (hover: hover) and (pointer: fine) {
    .mobile-controls { display: none; }
  }
</style>
</head>
<body>

<div class="game-wrap">
  <div class="hud">
    <div class="badge">Score: <strong id="scoreVal">0</strong></div>
    <div class="badge">Level: <strong id="levelVal">1</strong></div>
    <div class="badge">Best: <strong id="bestVal">0</strong></div>
    <div class="controls">
      <button class="btn" id="pauseBtn">Pause</button>
      <button class="btn" id="restartBtn">Restart</button>
    </div>
  </div>
  <canvas id="game" width="400" height="400"></canvas>
  <div class="vignette"></div>

  <div class="mobile-controls" id="mobileCtl">
    <div></div>
    <button class="ctl" data-d="up"><span>▲</span></button>
    <div></div>
    <button class="ctl" data-d="left"><span>◀</span></button>
    <div></div>
    <button class="ctl" data-d="right"><span>▶</span></button>
    <div></div>
    <button class="ctl" data-d="down"><span>▼</span></button>
    <div></div>
  </div>
</div>

<div id="startOverlay" class="overlay visible">
  <div class="panel">
    <p>Press <strong>Space</strong> or <strong>Tap</strong> to start</p>
    <p>Use <strong>← ↑ → ↓</strong> or on-screen controls</p>
  </div>
  
</div>

<div id="pauseOverlay" class="overlay">
  <div class="panel">
    <p>Paused – press <strong>Space</strong> to resume</p>
  </div>
  
</div>

<div id="gameOverOverlay" class="overlay">
  <div class="panel">
    <p id="gameOverMsg"></p>
    <p>Press <strong>Space</strong> to play again</p>
  </div>
  
</div>

<script>
/* --------------------------------------------------------------
   Neon Snake – single‑file, richer design
   --------------------------------------------------------------*/

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreVal = document.getElementById('scoreVal');
const bestVal = document.getElementById('bestVal');
const levelVal = document.getElementById('levelVal');
const pauseBtn = document.getElementById('pauseBtn');
const restartBtn = document.getElementById('restartBtn');

const startOverlay   = document.getElementById('startOverlay');
const pauseOverlay   = document.getElementById('pauseOverlay');
const gameOverOverlay = document.getElementById('gameOverOverlay');
const gameOverMsg   = document.getElementById('gameOverMsg');

const cfg = {
  rows: 20,
  cols: 20,
  cellSize: 20,
  // base speed in cells per second (will scale by level)
  baseSpeed: 10,
};

let snake, dir, food, score, lastTick, running, paused;
let level, speed, highScore, particles = [], shakeT = 0, shakeMag = 0;

// HiDPI scaling for crisp pixels
const DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
canvas.width = canvas.width * DPR;
canvas.height = canvas.height * DPR;
ctx.scale(DPR, DPR);

// --------------------------------------------------------------
// Helper functions
// --------------------------------------------------------------
function randomCell() {
  return {
    x: Math.floor(Math.random() * cfg.cols),
    y: Math.floor(Math.random() * cfg.rows),
  };
}

function drawRoundedRect(x, y, w, h, r, color) {
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
  ctx.fill();
}

function drawGrid() {
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.05)';
  ctx.lineWidth = 1;
  for (let x = 0; x <= cfg.cols; x++) {
    ctx.beginPath();
    ctx.moveTo(x * cfg.cellSize + 0.5, 0);
    ctx.lineTo(x * cfg.cellSize + 0.5, cfg.rows * cfg.cellSize);
    ctx.stroke();
  }
  for (let y = 0; y <= cfg.rows; y++) {
    ctx.beginPath();
    ctx.moveTo(0, y * cfg.cellSize + 0.5);
    ctx.lineTo(cfg.cols * cfg.cellSize, y * cfg.cellSize + 0.5);
    ctx.stroke();
  }
  ctx.restore();
}

function spawnParticles(x, y, count, color) {
  for (let i = 0; i < count; i++) {
    const a = Math.random() * Math.PI * 2;
    const v = 1 + Math.random() * 2.5;
    particles.push({
      x: x * cfg.cellSize + cfg.cellSize / 2,
      y: y * cfg.cellSize + cfg.cellSize / 2,
      vx: Math.cos(a) * v,
      vy: Math.sin(a) * v,
      life: 600 + Math.random() * 400,
      color,
      size: 2 + Math.random() * 2,
    });
  }
}

function updateParticles(dt) {
  for (const p of particles) {
    p.x += p.vx;
    p.y += p.vy;
    p.vx *= 0.98;
    p.vy *= 0.98;
    p.life -= dt;
  }
  particles = particles.filter(p => p.life > 0);
}

function renderParticles() {
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  for (const p of particles) {
    const a = Math.max(0, Math.min(1, p.life / 800));
    ctx.fillStyle = `rgba(0,255,200,${a})`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();
}

// --------------------------------------------------------------
// Game logic
// --------------------------------------------------------------
function initGame() {
  snake = [{ x: Math.floor(cfg.cols/2), y: Math.floor(cfg.rows/2) }];
  dir   = { x: 0, y: 0 };          // no movement until first tick
  food  = randomCell();
  score = 0;
  level = 1;
  speed = cfg.baseSpeed;
  highScore = Number(localStorage.getItem('neonSnakeBest') || 0);
  scoreVal.textContent = '0';
  levelVal.textContent = String(level);
  bestVal.textContent = String(highScore);
  lastTick = performance.now();
  running = false;
  paused  = false;
  particles = [];
  shakeT = 0; shakeMag = 0;

  // hide all overlays, show start screen
  startOverlay.classList.add('visible');
  pauseOverlay.classList.remove('visible');
  gameOverOverlay.classList.remove('visible');

  render(); // draw initial board
}

// --------------------------------------------------------------
function gameLoop(now) {
  if (!running) return; // stopped (paused or game‑over)

  const delta = now - lastTick;
  const stepMs = 1000 / speed; // ms per cell movement

  if (delta >= stepMs) {
    // ---- move snake -------------------------------------------------
    const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

    // wrap around
    head.x = (head.x + cfg.cols) % cfg.cols;
    head.y = (head.y + cfg.rows) % cfg.rows;

    // self‑collision
    if (snake.some(p => p.x === head.x && p.y === head.y)) {
      endGame();
      return;
    }

    snake.unshift(head);

    // eat food?
    if (head.x === food.x && head.y === food.y) {
      score++;
      scoreVal.textContent = String(score);
      // level up every 5 points
      if (score % 5 === 0) {
        level++;
        levelVal.textContent = String(level);
        speed = cfg.baseSpeed + level * 1.5;
        shakeMag = 6; shakeT = 150;
      }
      food = (() => {
        let f = randomCell();
        while (snake.some(s => s.x === f.x && s.y === f.y)) f = randomCell();
        return f;
      })();
      spawnParticles(head.x, head.y, 22, 'var(--snake-glow)');
      if (navigator.vibrate) navigator.vibrate(20);
    } else {
      snake.pop(); // keep length constant
    }

    lastTick = now;
  }

  updateParticles(delta);

  render();
  requestAnimationFrame(gameLoop);
}

// --------------------------------------------------------------
function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // camera shake
  ctx.save();
  if (shakeT > 0) {
    const dx = (Math.random() - 0.5) * shakeMag;
    const dy = (Math.random() - 0.5) * shakeMag;
    ctx.translate(dx, dy);
    shakeT -= 16;
    shakeMag *= 0.95;
  }

  // ---- draw food (pulsing) -----------------------------------------
  const pulse = Math.sin(performance.now() / 200) * 0.3 + 0.7;
  const foodColor = `rgba(255,77,77,${pulse})`;
  drawGrid();

  // glow
  ctx.save();
  ctx.shadowColor = 'rgba(255,77,109,0.6)';
  ctx.shadowBlur = 12;
  drawRoundedRect(
    food.x * cfg.cellSize,
    food.y * cfg.cellSize,
    cfg.cellSize,
    cfg.cellSize,
    4,
    foodColor
  );
  ctx.restore();

  // ---- draw snake ---------------------------------------------------
  const n = snake.length;
  snake.forEach((seg, i) => {
    const t = i / Math.max(1, n - 1);
    const r = 0x00 + Math.floor((0x15 - 0x00) * t);
    const g = 0xff - Math.floor((0xff - 0xd1) * t);
    const b = 0xcc - Math.floor((0xcc - 0xa3) * t);
    const color = `rgb(${r},${g},${b})`;
    ctx.save();
    ctx.shadowColor = 'rgba(0,255,200,0.6)';
    ctx.shadowBlur = i === 0 ? 18 : 10;
    drawRoundedRect(
      seg.x * cfg.cellSize,
      seg.y * cfg.cellSize,
      cfg.cellSize,
      cfg.cellSize,
      5,
      i === 0 ? 'var(--snake-head)' : color
    );
    ctx.restore();
  });

  renderParticles();

  ctx.restore(); // end shake
}

// --------------------------------------------------------------
function startPlay() {
  // hide start overlay, start moving right
  startOverlay.classList.remove('visible');
  dir = { x: 1, y: 0 };
  running = true;
  paused = false;
  requestAnimationFrame(gameLoop);
}

// --------------------------------------------------------------
function togglePause() {
  if (!running) return; // nothing to pause

  paused = !paused;
  if (paused) {
    pauseOverlay.classList.add('visible');
    running = false; // stop the loop
  } else {
    pauseOverlay.classList.remove('visible');
    running = true;
    requestAnimationFrame(gameLoop);
  }
}

// --------------------------------------------------------------
function endGame() {
  running = false;
  highScore = Math.max(highScore, score);
  localStorage.setItem('neonSnakeBest', String(highScore));
  bestVal.textContent = String(highScore);
  gameOverMsg.textContent = `Game Over! Score: ${score}  •  Best: ${highScore}`;
  gameOverOverlay.classList.add('visible');
  spawnParticles(snake[0].x, snake[0].y, 60, 'rgba(255,77,109,0.9)');
  shakeMag = 10; shakeT = 300;
}

// --------------------------------------------------------------
document.addEventListener('keydown', e => {
  switch (e.key) {
    case 'ArrowUp':
      if (dir.y !== 1) dir = { x: 0, y: -1 };
      break;
    case 'ArrowDown':
      if (dir.y !== -1) dir = { x: 0, y: 1 };
      break;
    case 'ArrowLeft':
      if (dir.x !== 1) dir = { x: -1, y: 0 };
      break;
    case 'ArrowRight':
      if (dir.x !== -1) dir = { x: 1, y: 0 };
      break;
    case ' ':
      if (!running && !paused) {
        // first press → start the game
        startPlay();
      } else if (paused) {
        togglePause(); // resume
      } else {
        togglePause(); // pause
      }
      break;
  }
});

// Buttons
pauseBtn.addEventListener('click', () => {
  if (!running && !paused) return; // can't pause before start
  togglePause();
});
restartBtn.addEventListener('click', () => {
  initGame();
});

// Mobile controls
document.getElementById('mobileCtl').addEventListener('click', (e) => {
  const btn = e.target.closest('.ctl');
  if (!btn) return;
  const d = btn.getAttribute('data-d');
  if (d === 'up'    && dir.y !== 1)  dir = { x: 0, y: -1 };
  if (d === 'down'  && dir.y !== -1) dir = { x: 0, y: 1 };
  if (d === 'left'  && dir.x !== 1)  dir = { x: -1, y: 0 };
  if (d === 'right' && dir.x !== -1) dir = { x: 1, y: 0 };
  if (!running && !paused) startPlay();
});

// --------------------------------------------------------------
initGame();
</script>
</body>
</html>